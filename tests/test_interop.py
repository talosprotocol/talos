"""
Cross-Language Interoperability Tests.

Verifies that cryptographic operations and message formats are compatible
between the Python core protocol and the TypeScript SDK.

Test Vectors:
- TypeScript SDK generates test vectors to test_vectors/ts_generated/
- Python verifies these vectors match expected outputs
"""

import pytest
import json
import base64
import hashlib
from pathlib import Path

from src.core.crypto import verify_signature, sign_message
from src.core.capability import Capability


# Path to test vectors generated by TypeScript
VECTORS_ROOT = Path(__file__).parent.parent / "test_vectors"
TS_VECTORS_PATH = VECTORS_ROOT / "ts_generated" / "interop.json"


class TestCrossLanguageInterop:
    """Test cross-language interoperability between Python and TypeScript."""

    @pytest.fixture
    def ts_vectors(self):
        """Load TypeScript-generated test vectors."""
        if not TS_VECTORS_PATH.exists():
            pytest.skip(f"TypeScript vectors not found at {TS_VECTORS_PATH}")
        
        with open(TS_VECTORS_PATH) as f:
            return json.load(f)

    def test_vectors_file_exists(self):
        """Verify TypeScript vectors file exists."""
        if not TS_VECTORS_PATH.exists():
            pytest.skip("Run 'npm test' in sdk/typescript first to generate vectors")
        
        assert TS_VECTORS_PATH.exists()

    def test_ed25519_signature_verification(self, ts_vectors):
        """Verify Python can verify Ed25519 signatures from TypeScript."""
        if "signed_capability" not in ts_vectors:
            pytest.skip("No signed_capability in vectors")

        cap_data = ts_vectors["signed_capability"]
        
        # Extract signature and public key
        sig_b64 = cap_data.get("sig")
        pub_key_b64 = ts_vectors.get("public_key")
        
        if not sig_b64 or not pub_key_b64:
            pytest.skip("Missing signature or public key in vectors")
        
        sig = base64.urlsafe_b64decode(sig_b64 + "==")  # Add padding
        pub_key = base64.urlsafe_b64decode(pub_key_b64 + "==")
        
        # Reconstruct content that was signed (cap without signature)
        content = {k: v for k, v in cap_data.items() if k != "sig"}
        content_bytes = json.dumps(content, sort_keys=True, separators=(',', ':')).encode()
        
        # Verify signature using Python crypto
        is_valid = verify_signature(content_bytes, sig, pub_key)
        assert is_valid, "TypeScript signature should verify in Python"

    def test_capability_hash_consistency(self, ts_vectors):
        """Verify capability hash calculation matches between languages."""
        if "capability_hash" not in ts_vectors:
            pytest.skip("No capability_hash in vectors")

        cap_data = ts_vectors.get("signed_capability", {})
        expected_hash = ts_vectors["capability_hash"]
        
        # Remove signature for hashing (if present)
        content = {k: v for k, v in cap_data.items() if k != "sig"}
        content_bytes = json.dumps(content, sort_keys=True, separators=(',', ':')).encode()
        
        # Compute hash
        computed_hash = hashlib.sha256(content_bytes).hexdigest()
        
        assert computed_hash == expected_hash, \
            f"Hash mismatch: Python={computed_hash}, TypeScript={expected_hash}"

    def test_request_hash_consistency(self, ts_vectors):
        """Verify MCP request hash calculation matches."""
        if "request_hash" not in ts_vectors:
            pytest.skip("No request_hash in vectors")

        request = ts_vectors.get("mcp_request", {})
        expected_hash = ts_vectors["request_hash"]
        
        # Compute hash using Python
        request_bytes = json.dumps(request, sort_keys=True, separators=(',', ':')).encode()
        computed_hash = hashlib.sha256(request_bytes).hexdigest()
        
        assert computed_hash == expected_hash, \
            f"Request hash mismatch: Python={computed_hash}, TypeScript={expected_hash}"

    def test_response_hash_consistency(self, ts_vectors):
        """Verify MCP response hash calculation matches."""
        if "response_hash" not in ts_vectors:
            pytest.skip("No response_hash in vectors")

        response = ts_vectors.get("mcp_response", {})
        expected_hash = ts_vectors["response_hash"]
        
        # Compute hash using Python
        response_bytes = json.dumps(response, sort_keys=True, separators=(',', ':')).encode()
        computed_hash = hashlib.sha256(response_bytes).hexdigest()
        
        assert computed_hash == expected_hash, \
            f"Response hash mismatch: Python={computed_hash}, TypeScript={expected_hash}"

    def test_base64url_encoding_consistency(self, ts_vectors):
        """Verify base64url encoding is consistent."""
        if "base64url_test" not in ts_vectors:
            pytest.skip("No base64url_test in vectors")

        test_data = ts_vectors["base64url_test"]
        raw_bytes = bytes.fromhex(test_data["hex"])
        expected_b64 = test_data["base64url"]
        
        # Python base64url encoding
        computed_b64 = base64.urlsafe_b64encode(raw_bytes).rstrip(b"=").decode()
        
        assert computed_b64 == expected_b64, \
            f"Base64url mismatch: Python={computed_b64}, TypeScript={expected_b64}"

    def test_canonical_json_consistency(self, ts_vectors):
        """Verify canonical JSON encoding is consistent."""
        if "canonical_json_test" not in ts_vectors:
            pytest.skip("No canonical_json_test in vectors")

        test_obj = ts_vectors["canonical_json_test"]["object"]
        expected_canonical = ts_vectors["canonical_json_test"]["canonical"]
        
        # Python canonical JSON (sorted keys, no spaces)
        computed_canonical = json.dumps(test_obj, sort_keys=True, separators=(',', ':'))
        
        assert computed_canonical == expected_canonical, \
            f"Canonical JSON mismatch:\nPython: {computed_canonical}\nTypeScript: {expected_canonical}"


class TestPythonToTypeScriptInterop:
    """Generate test vectors for TypeScript to verify."""

    @pytest.fixture
    def vectors_dir(self):
        """Get or create Python vectors directory."""
        path = VECTORS_ROOT / "py_generated"
        path.mkdir(parents=True, exist_ok=True)
        return path

    def test_generate_python_vectors(self, vectors_dir):
        """Generate test vectors for TypeScript to verify."""
        from src.core.crypto import generate_signing_keypair
        
        # Generate test keypair
        key_pair = generate_signing_keypair()
        priv_key = key_pair.private_key
        pub_key = key_pair.public_key
        
        # Create test capability structure
        cap_content = {
            "v": "1",
            "iss": "did:talos:python_test",
            "sub": "did:talos:agent123",
            "scope": "tools/filesystem/read",
            "iat": 1700000000,
            "exp": 1700003600,
            "constraints": {"paths": ["/data/*"]}
        }
        
        # Canonicalize and sign
        content_bytes = json.dumps(cap_content, sort_keys=True, separators=(',', ':')).encode()
        signature = sign_message(content_bytes, priv_key)
        
        # Create MCP request
        mcp_request = {
            "jsonrpc": "2.0",
            "method": "tools/call",
            "params": {
                "name": "read_file",
                "arguments": {"path": "/data/test.txt"}
            },
            "id": "req_123"
        }
        
        # Create MCP response
        mcp_response = {
            "jsonrpc": "2.0",
            "result": {"content": "file contents"},
            "id": "req_123"
        }
        
        # Compute hashes
        cap_hash = hashlib.sha256(content_bytes).hexdigest()
        req_bytes = json.dumps(mcp_request, sort_keys=True, separators=(',', ':')).encode()
        req_hash = hashlib.sha256(req_bytes).hexdigest()
        resp_bytes = json.dumps(mcp_response, sort_keys=True, separators=(',', ':')).encode()
        resp_hash = hashlib.sha256(resp_bytes).hexdigest()
        
        # Build vectors file
        vectors = {
            "generator": "python",
            "version": "1.0.0",
            "public_key": base64.urlsafe_b64encode(pub_key).rstrip(b"=").decode(),
            "signed_capability": {
                **cap_content,
                "sig": base64.urlsafe_b64encode(signature).rstrip(b"=").decode()
            },
            "capability_hash": cap_hash,
            "mcp_request": mcp_request,
            "request_hash": req_hash,
            "mcp_response": mcp_response,
            "response_hash": resp_hash,
            "base64url_test": {
                "hex": "deadbeef",
                "base64url": base64.urlsafe_b64encode(bytes.fromhex("deadbeef")).rstrip(b"=").decode()
            },
            "canonical_json_test": {
                "object": {"z": 1, "a": 2, "nested": {"b": 3, "a": 4}},
                "canonical": json.dumps({"z": 1, "a": 2, "nested": {"b": 3, "a": 4}}, sort_keys=True, separators=(',', ':'))
            }
        }
        
        # Write vectors file
        output_path = vectors_dir / "interop.json"
        with open(output_path, "w") as f:
            json.dump(vectors, f, indent=2)
        
        print(f"\nPython interop vectors written to: {output_path}")
        assert output_path.exists()
