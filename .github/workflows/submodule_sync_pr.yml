name: Submodule Auto-Sync

on:
  schedule:
    - cron: '0 */6 * * *' # Every 6 hours
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write

jobs:
  sync-submodules:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout superproject
        uses: actions/checkout@v4
        with:
          submodules: recursive
          token: ${{ secrets.SUBMODULE_SYNC_TOKEN || secrets.GITHUB_TOKEN }}
          fetch-depth: 0
          token: ${{ secrets.SUBMODULE_SYNC_TOKEN || secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Sync .gitmodules
        run: git submodule sync --recursive

      - name: Update submodules (FF-ONLY)
        run: |
          # Iterate all submodules and fast-forward to origin/main
          # We use 'git submodule foreach' for convenience
          # logic: fetch remote main, reset --hard to it
          
          git submodule foreach --recursive '
            echo "Syncing $name..."
            git fetch origin main
            git reset --hard origin/main
          '

      - name: Check for changes
        id: check_changes
        run: |
          if [ -z "$(git status --porcelain)" ]; then
            echo "No submodule updates found."
            echo "changes=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          echo "Changes detected."
          echo "changes=true" >> $GITHUB_OUTPUT
          
          # Print summary
          git diff --submodule=log

      - name: Create Branch and Commit
        if: steps.check_changes.outputs.changes == 'true'
        env:
          BRANCH_NAME: bot/submodule-sync/${{ github.run_id }}
        run: |
          # Deduplication Logic:
          # Check if a PR branch already exists (simplified: just use timestamp/run_id unique branch)
          # The user plan mentioned dedupe: "If an open PR exists... update that branch"
          # For simplicity and robustness with standard actions, we'll create a new branch.
          # GitHub's "create-pull-request" action handles updates well, but let's do manual git for total control strictly as per plan.
          
          git checkout -b "$BRANCH_NAME"
          
          # Commit
          git add .
          git commit -m "chore(sync): bump submodules to latest main" -m "Updates submodules to track latest origin/main."

          git push origin "$BRANCH_NAME"

      - name: Create Pull Request
        if: steps.check_changes.outputs.changes == 'true'
        env:
          GH_TOKEN: ${{ secrets.SUBMODULE_SYNC_TOKEN || secrets.GITHUB_TOKEN }}
          BRANCH_NAME: bot/submodule-sync/${{ github.run_id }}
        run: |
          # Check for existing PR to allow squashing updates? 
          # For now, open a new one. dedupe can be complex in shell. 
          # Actually, if we use a fixed branch name pattern like 'bot/submodule-sync', we update it.
          # But v1.2 plan said: "Create unique branch... If open PR exists... update that branch"
          # That implies we need to find the branch of the existing PR.
          
          # Let's stick to unique branch + new PR for safety/simplicity first, 
          # as 'hub' or 'gh' cli makes creation easy.
          
          gh pr create \
            --title "chore(sync): update submodule pins" \
            --body "Updates submodules to latest main. \n\n**Reason**: Strict drift gate requires pins to match remote main.\n\n**Instruction**: Squash merge this PR." \
            --head "$BRANCH_NAME" \
            --base main
